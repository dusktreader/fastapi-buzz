{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"fastapi-buzz","text":"<p>py-buzz bindings specifically for FastAPI applications</p>"},{"location":"#overview","title":"Overview","text":"<p>This package extends the functionality from the <code>py-buzz</code> package to add some sugar for FastAPI apps.  <code>FastAPIBuzz</code> provides an exception handler builder to create nice error responses with the right status code and information included in the response body. This means that client code can simply register an error handler with their FastAPI app to supply fully prepared api responses for specific exception types.</p> <p>Setting up your FastAPI app to return nicely formatted error responses when FastAPIBuzz exceptions are raised is as simple as:</p> <pre><code>app.add_exception_handler(*FastAPIBuzz.build_error_handler())\n</code></pre> <p>See examples/basic.py</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#error-codes","title":"Error Codes","text":"<p>Each <code>FastAPIBuzz</code> exception has a <code>status_code</code> class attribute. This should correlate to the type of problem that happened. For example, the default is the generic <code>INTERNAL_SERVICE_ERROR</code> (500). This just means there was a problem in the application code itself. It is recommended to use different, informative status codes for your different derived error classes.</p>"},{"location":"features/#fastapi-compatible-build_json_response","title":"FastAPI compatible <code>build_json_response()</code>","text":"<p>In order to make packaging exceptions into normal FastAPI responses easy, this library adds a <code>build_json_response()</code> method. This method composes a FastAPI JSON response with the appropriate <code>status_code</code> and the exception message included in the body.</p> <p>For example, your route/resource might want to raise a custom exception on certain behaviors and have a response that informs of the error:</p> <pre><code>class InvalidParameters(FastAPIBuzz):\n    status_code: int = status.HTTP_412_PRECONDITION_FAILED\n\n\ndef check_params(id: int | None = None, **_):\n    InvalidParameters.require_condition(id, \"id field must be defined\")\n\n\n@app.get('/any')\ndef index(request: Request):\n    params: dict[str, Any] = request.query_params\n    try:\n        check_params(**params)\n        return JSONResponse(content=dict(message=\"All good!\"))\n    except InvalidParameters as err:\n        return err.build_json_response(origin=\"index\")\n</code></pre>"},{"location":"features/#install-error-handler-for-fastapi","title":"Install error handler for FastAPI","text":"<p>The <code>fastapi-buzz</code> package also has the ability to set up a FastAPI error handler for <code>FastAPIBuzz exceptions</code>. This allows any code called in the course of request to raise a <code>FastAPIBuzz</code> derived exception and have FastAPI automatically return a properly formatted JSON error response:</p> <pre><code>app.add_exception_handler(*FastAPIBuzz.build_error_handler())\n\n\n@app.get(\"/\")\ndef index():\n    raise FastAPIBuzz(\"Something went wrong\")\n</code></pre> <p>Note</p> <p>Notice that the unpack/splat (<code>*</code>) operator is applied to the return value of <code>build_error_handler</code>. This is because FastAPI's <code>register_error_handler</code> takes two arguments:</p> <ul> <li>The type of exception to handle</li> <li>A function that should be passed exception instances when they are caught</li> </ul> <p><code>FastAPIBuzz</code> returns a tuple that includes:</p> <ul> <li>The class type that is being registered</li> <li>A handler function to call</li> </ul>"},{"location":"features/#adding-tasks-to-error-handlers","title":"Adding tasks to error handlers","text":"<p><code>FastAPIBuzz</code> error handlers support adding additional tasks to be executed when a <code>FastAPIBuzz</code> exception is handled. For example, you might wish to log the exceptions before returning the response.</p> <p>Each task should be a callable that takes exactly one argument: the exception instance itself. These callables are passed as additional positional arguments:</p> <pre><code>def log_error(err):\n    logger.error(err)\n\napp.add_exception_handler(*FastAPIBuzz.build_error_handler(log_error))\n</code></pre>"},{"location":"features/#debug-mode","title":"Debug Mode","text":"<p>By default, the error response provided by <code>FastAPIBuzz</code> error handlers include the <code>base_message</code> for the exception. This is important only for exceptions raised by the <code>handle_errors()</code> (or <code>check_expressions()</code>) context manager. This is because <code>handle_errors()</code> includes information about the handled error in its message. The <code>base_message</code> does not include the full message. This is important for production/public apps where you do not wish to expose internal details to clients.</p> <p>If you want to get more information in the response to help with debugging, you can enable \"Debug Mode\" with <code>FastAPIBuzz</code> by setting the class property <code>debug</code> to <code>True</code>:</p> <pre><code>FastAPIBuzz.debug = True\n</code></pre> <p>When that flag is set, the full error message (including any handled error info) is included in the response. Additionally, a stringified representation of the handled error is also included in the payload. Finally, when \"Debug Mode\" is enabled, the response headers are also included in the body.</p>"},{"location":"quickstart/","title":"Quickstart","text":""},{"location":"quickstart/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 to 3.13</li> </ul>"},{"location":"quickstart/#installation","title":"Installation","text":""},{"location":"quickstart/#install-from-pypi","title":"Install from pypi:","text":"<p>This will install the latest release from pypi via pip:</p> <pre><code>pip install fastapi-buzz\n</code></pre>"},{"location":"quickstart/#install-latest-version-from-github","title":"Install latest version from github","text":"<p>If you would like a version other than the latest published on pypi, you may do so by cloning the git repository:</p> <pre><code>git clone https://github.com/dusktreader/fastapi-buzz.git\n</code></pre> <p>Next, checkout the branch or tag that you wish to use:</p> <pre><code>cd fastapi-buzz\ngit checkout integration\n</code></pre> <p>Finally, use uv to install from the local directory:</p> <pre><code>uv sync\n</code></pre>"},{"location":"quickstart/#using","title":"Using","text":"<p>See examples/basic.py for an example of how to use this exception package.</p>"},{"location":"reference/","title":"fastapi-buzz Reference","text":""},{"location":"reference/#fastapi_buzz","title":"fastapi_buzz","text":""},{"location":"reference/#fastapi_buzz.FastAPIBuzz","title":"FastAPIBuzz","text":"<p>               Bases: <code>Buzz</code></p>"},{"location":"reference/#fastapi_buzz.FastAPIBuzz.build_error_handler","title":"build_error_handler  <code>classmethod</code>","text":"<pre><code>build_error_handler(\n    *tasks: FastAPIBuzzTask,\n) -&gt; tuple[type[Self], HTTPExceptionHandler]\n</code></pre> <p>Build an error handling function specifically for FastAPIBuzz errors.</p> <p>The resulting error handler function will catch any FastAPIBuzz exceptions and raise an HTTPException that encapsulates the details of the original.</p> <p>Descendants of the exception will also be caught and handled.</p> <p>Example usage:</p> <pre><code>app.add_exception_handler(*FastAPIBuzz.build_error_handler())\n</code></pre> <p>You may also add extra tasks that will operate on the error prior raising the final HTTPException:</p> <pre><code>app.register_error_handler(*FastAPIBuzz.build_error_handler(print, lambda e: jawa(e)))\n</code></pre> <p>This latter example will print the error to stdout and also call the <code>jawa()</code> function with the error prior to raising the final HTTPException.</p>"},{"location":"reference/#fastapi_buzz.FastAPIBuzz.build_json_response","title":"build_json_response","text":"<pre><code>build_json_response(\n    status_code: int | None = None,\n    message: str | None = None,\n    headers: dict[str, str] | None = None,\n    **kwargs: Any,\n) -&gt; JSONResponse\n</code></pre> <p>Build a json response from the FastAPI error in form that is compatible with FastAPI.</p> <p>Keyword arguments allow custom data to be included in the rsponse's body when it is built.</p> <p>If <code>debug</code> is set, the stringified exception will be included in the response body as well. For apps running in production or publicly should not run in debug mode as this could expose internal information to clients.</p> <p>Args:</p> <pre><code>status_code: The status code to include in the response. If not supplied, use instance status_code.\nmessage:     The message to include in the response. If not supplied, use instance message. If debug\n             is set and the base_message is not None, use the base_message instead. This is important,\n             because if the exception was raised by `handle_errors`, the full message will return\n             details of the handled exception as well as the base message. This information should\n             probably not be returned to the client.\nheaders:     The headers to attach to the response. If not supplied, use instance headers. If the\n             instance has no headers, don't include headers.\nkwargs:      Additional fields that should be set in the response body. These must be JSON\n             serializable.\n</code></pre>"}]}